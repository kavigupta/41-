\documentclass{article}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{footnote}
\makesavenoteenv{tabular}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\codeblock}[1]{\begin{quote}\code{#1}\end{quote}}

\begin{document}
\section{Types}
\subsection{Primitives}
Primitive types are types that do not have fields. Instead, they merely have values. These can take the form:
\begin{itemize}
\item \code{number}: a numeric type. This includes both integers and floating point numbers. Calculations internally are handled using high precision, large numbers.
\item \code{character}: a character type. This is basically an integer that will be shown as a character.
\item \code{bool}: a boolean type. \code{true} or \code{false}.
\item \code{type}: a type type. This type is the type of the \emph{values} (not types!) \code{number}, \code{type}, \code{array of string}.
\end{itemize}
\subsection{Defined types}
Defined types are the types of structures with fields. These fields can be themselves defined types or primitives.
\subsection{Compound types}
Compound types are types that take other types as arguments, similar to Haskell's type constructors. A common example is \code{array} which can only be declared as \code{array of T}, where \code{T} is the type stored in the array. Compound types are always defined types, because types are fields.
\section{Variables}
Although variables without prefixes would normally be beneficial in a natural-like language like 41++, they could possibly cause ambiguity with Arbitrary Syntax Functions. Therefore, all variables must start with the underscore character \code{_}. The other restriction is that variable names cannot contain spaces or start with a number or \code{'}.
\section{Expressions}
\subsection{Literals}
Literals are expressions that are hard-coded into the code. They take one of four forms.
\subsection{Numeric Literals}
These must start with a digit, a plus sign, a minus sign, or a period.
\subsection{Boolean Literals}
Either \code{true} or \code{false}.
\subsection{Character and String Literals}
These must start and end with a single quote \code{'}. What is in between is interpreted as a string. To use an actual single quote mark, use \code{\textbackslash'}. Standard escapes can also be used. Determining the type of a string falls into three cases.
\begin{itemize}
\item \code{''}: This is automatically a string literal representing an empty string.
\item A single character: depending on the context, this is interpreted as a string or character.
\item Multiple characters: always a string.
\end{itemize}
\subsubsection{Examples}
\begin{itemize}
\item \code{2}, \code{-56543234565}, \code{41}, \code{-.02345654321}, \code{12.}: Numeric literals.
\item \code{'"'}, \code{'1'}, \code{'\textbackslash{}r'}, \code{'\textbackslash{}n'}, \code{'\textbackslash{}t'}, \code{'\textbackslash{}0123'}: Character literals
\item \code{''}, \code{'\textbackslash'\textbackslash''}, \code{'41++'}: String literals.
\end{itemize}
\subsection{Algebraic Expressions}
\begin{tabular}{|l|l|p{8cm}|}
\hline
Algebraic Expression & Type\\
\hline
\code{=} & \code{a = a -> bool}\\
\hline
\code{>} & \code{number > number -> bool} and \code{char > char -> bool}\\
\hline
\code{<} & \code{number < number -> bool} and \code{char < char -> bool}\\
\hline
\code{>=}& \code{number >= number -> bool} and \code{char >= char -> bool}\\
\hline
\code{<=} & \code{number <= number -> bool} and \code{char <= char -> bool}\\
\hline
\code{+}& \code{number + number -> number} and \code{char + char -> char} and \code{char + number -> number}\\
\hline
\code{-} & \code{number - number -> number} and \code{char - char -> char} and \code{char - number -> number}\\
\hline
\code{*} & \code{number * number = number}\\
\hline
\code{/} & \code{number / number = number}\footnote{this is standard division. \code{11/2 = 5.5}}\\
\hline
\code{//} & \code{number // number = number}\footnote{this is floor division. \code{11/2 = 5, 1.5 / 1 = 1, -1.5 / 1.2 = -1}}\\
\code{\%} & \code{number \% number = number}\footnote{remainder}\\
\hline
\end{tabular}
\subsection{Function Expressions}
See the section on functions for more details.
\subsection{The Role of Parentheses}
While 41++ is designed to be a English-like language, it is often very difficult to tease out syntactical ambiguity without parentheses. Therefore, in 41++, parentheses must surround any value that is not a single word or string literal.
\section{Statements}
There are a limited number of valid statement forms. All start with a capital letter and end with a period.
\subsection{Definition}
\subsubsection{Declaration}
A minimal declaration simply provides a variable with a name and associates it with a type.

\codeblock{Define a[n] <type> called <name>.}

\subsubsection{Field Initialization}
A variable can also have its fields initialized. It can also be directly set to a value by using the special field \code{value}.

\codeblock{Define a[n] <type> called <name> with a[n] <field1> of <value1>, a[n] <field2> of <value2>, and a[n] <field3> of <value3>.}

\noindent Commas and \code{and} are all technically unnecessary, but included to insure readability. Similarly, \code{a} and \code{an} are equivalent but both are included to avoid statements like \code{Define a integer called x.}
\subsubsection{Examples}

\codeblock{Define an integer called x.}

\codeblock{Define a string called name with a value of '41++'.}

\codeblock{Define a matrix called M with a width of 3 and a height of 2. Define a matrix called M2 with a value of M.}

\end{document}